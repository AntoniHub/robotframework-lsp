import os
import subprocess
import sys
import logging
from collections import namedtuple

log = logging.getLogger(__name__)

_LibInfo = namedtuple("_LibInfo", "library_doc, mtime")


class LibspecManager(object):
    """
    Used to manage the libspec files.
    
    .libspec files are searched in the following directories:

    - PYTHONPATH folders               (not recursive)
    - Workspace folders                (recursive -- notifications from the LSP)
    - ${user}robotframework_ls/lispec/ (not recursive)

    It searches for .libspec files in the folders tracked and provides the
    keywords that are available from those (properly caching data as needed).
    """

    def __init__(self, user_home=None):

        try:
            from concurrent import futures
        except ImportError:
            from robotframework_ls.libs_py2.concurrent import futures

        from multiprocessing import cpu_count

        self._thread_pool = futures.ThreadPoolExecutor(
            max_workers=(cpu_count() * 1.2) + 1
        )

        self._workspace_folders_tracked = set()

        # Spec info found in the workspace
        self._workspace_libspec_filename_to_info = {}

        # Spec info found in the pythonpath
        self._pythonpath_libspec_filename_to_info = {}

        # Spec info found in internal dirs (autogenerated)
        self._internal_libspec_filename_to_info = {}

        if user_home is None:
            user_home = os.getenv("ROBOTFRAMEWORK_LS_USER_HOME", None)
            if user_home is None:
                user_home = os.path.expanduser("~")

        self._user_home = user_home

        pyexe = sys.executable
        if not isinstance(pyexe, bytes):
            pyexe = pyexe.encode("utf-8")

        import hashlib

        digest = hashlib.sha256(pyexe).hexdigest()[:8]

        try:
            import robot

            v = str(robot.version.VERSION)
        except:
            v = "unknown"

        self._libspec_dir = os.path.join(
            user_home, "robotframework_ls", "libspec", "%s_%s" % (digest, v)
        )

        log.debug("Libspec dir: %s", self._libspec_dir)

        try:
            os.makedirs(self._libspec_dir)
        except:
            # Ignore exception if it's already created.
            pass

        self._sync_builtin_libraries()

    @property
    def libspec_dir(self):
        return self._libspec_dir

    def add_workspace_folder(self, folder_uri):
        if folder_uri not in self._workspace_folders_tracked:
            self._workspace_folders_tracked.add(folder_uri)

    def remove_workspace_folder(self, folder_uri):
        if folder_uri in self._workspace_folders_tracked:
            self._workspace_folders_tracked.discard(folder_uri)

    def _collect_libspec_info(self, folders, old_libspec_filename_to_info, recursive):
        seen_libspec_files = set()
        if recursive:
            for folder in folders:
                if os.path.isdir(folder):
                    for root, _dirs, files in os.walk(folder):
                        for filename in files:
                            if filename.lower().endswith(".libspec"):
                                seen_libspec_files.add(os.path.join(root, filename))
        else:
            for folder in folders:
                if os.path.isdir(folder):
                    for filename in os.listdir(folder):
                        if filename.lower().endswith(".libspec"):
                            seen_libspec_files.add(os.path.join(folder, filename))

        new_libspec_filename_to_info = {}

        for filename in seen_libspec_files:
            info = old_libspec_filename_to_info.get(filename)
            if info is not None:
                try:
                    curr_mtime = os.path.getmtime(filename)
                except:
                    # it was deleted in the meanwhile...
                    continue
                else:
                    if info.mtime != curr_mtime:
                        info = None

            new_libspec_filename_to_info[filename] = info
        return new_libspec_filename_to_info

    def _sync_builtin_libraries(self):
        """
        Generates .lispec files for the libraries builtin (if needed).
        """
        try:
            from robotframework_ls.impl import robot_constants

            self.synchronize()

            wait_for = []
            for libname in robot_constants.STDLIBS:
                library_info = self.get_library_info(libname, create=False)
                if library_info is None:
                    wait_for.append(
                        self._thread_pool.submit(
                            self.create_libspec, libname, retry=False
                        )
                    )
            for future in wait_for:
                future.result()
        except:
            log.exception("Error creating builtin libraries.")

    def synchronize(self):
        """
        Updates the internal caches related to the tracked .libspec files found.
        """
        from robotframework_ls import uris

        self._workspace_libspec_filename_to_info = self._collect_libspec_info(
            [uris.to_fs_path(folder) for folder in self._workspace_folders_tracked],
            self._workspace_libspec_filename_to_info,
            recursive=True,
        )

        self._pythonpath_libspec_filename_to_info = self._collect_libspec_info(
            list(sys.path), self._pythonpath_libspec_filename_to_info, recursive=False
        )

        self._internal_libspec_filename_to_info = self._collect_libspec_info(
            [self._libspec_dir],
            self._internal_libspec_filename_to_info,
            recursive=False,
        )

    def _iter_library_doc(self):
        """
        :rtype: generator(LibraryDoc)
        """
        found_libraries = set()

        for filename_to_info in [
            self._workspace_libspec_filename_to_info,
            self._pythonpath_libspec_filename_to_info,
            self._internal_libspec_filename_to_info,
        ]:
            for filename, info in list(filename_to_info.items()):
                if info is not None:
                    try:
                        if info.mtime != os.path.getmtime(filename):
                            info = None
                    except:
                        continue
                if info is None:
                    info = filename_to_info[filename] = self._load_info(filename)

                if info is not None and info.library_doc is not None:
                    if info.library_doc.name not in found_libraries:
                        found_libraries.add(info.library_doc.name)
                        yield info.library_doc

    def _load_info(self, filename):
        from robotframework_ls.impl import robot_specbuilder

        builder = robot_specbuilder.SpecDocBuilder()
        try:
            mtime = os.path.getmtime(filename)
            libdoc = builder.build(filename)
            return _LibInfo(libdoc, mtime)
        except Exception:
            log.exception("Error when loading spec info from: %s", filename)
            return None

    def get_library_names(self):
        return [library_doc.name for library_doc in self._iter_library_doc()]

    def create_libspec(self, libname, env=None, retry=True, log_time=True):
        """
        :param str libname:
        :raise Exception: if unable to create the library.
        """
        from robotframework_ls import uris
        import time

        curtime = time.time()

        try:
            log.debug("Generating libspec for: %s", libname)
            call = [sys.executable]
            call.extend("-m robot.libdoc --format XML:HTML".split())
            call.append(libname)
            target = os.path.join(self._libspec_dir, libname + ".libspec")
            call.append(target)

            mtime = -1
            try:
                mtime = os.path.getmtime(target)
            except:
                pass

            try:
                try:
                    # Note: stdout is always subprocess.PIPE in this call.
                    subprocess.check_output(
                        call, stderr=subprocess.STDOUT, stdin=subprocess.PIPE, env=env
                    )
                except OSError as e:
                    log.exception("Error calling: %s", call)
                    # We may have something as: Ignore OSError: [WinError 6] The handle is invalid,
                    # give the result based on whether the file changed on disk.
                    try:
                        if mtime != os.path.getmtime(target):
                            return True
                    except:
                        pass

                    if not retry:
                        log.debug("Not retrying after OSError failure.")
                        return False

                    log.debug("Retrying after OSError failure.")
                    raise subprocess.CalledProcessError(1, call, b"ImportError")

            except subprocess.CalledProcessError as e:
                if b"ImportError" in e.output or b"ModuleNotFoundError" in e.output:
                    if retry:
                        as_path = libname.replace(".", "/")
                        as_path += ".py"
                        for folder in self._workspace_folders_tracked:
                            folder = uris.to_fs_path(folder)
                            if os.path.exists(os.path.join(folder, as_path)):
                                # Let's see if we can find the module in the workspace (if we
                                # can, fix the PYTHONPATH to include it).
                                env_cp = os.environ.copy()
                                env_cp["PYTHONPATH"] = (
                                    folder
                                    + os.pathsep
                                    + os.environ.get("PYTHONPATH", "")
                                )
                                return self.create_libspec(
                                    libname, env=env_cp, retry=False, log_time=False
                                )

                log.exception(
                    "Error creating libspec: %s. Output:\n%s", libname, e.output
                )
                return False
            return True
        finally:
            if log_time:
                delta = time.time() - curtime
                log.debug("Took: %.2fs to generate info for: %s" % (delta, libname))

    def dispose(self):
        pass

    def get_library_info(self, libname, create=True):
        """
        :rtype: LibraryDoc
        """
        libname_lower = libname.lower()
        for library_doc in self._iter_library_doc():
            if library_doc.name and library_doc.name.lower() == libname_lower:
                return library_doc

        if create:
            if self.create_libspec(libname):
                self.synchronize()
                return self.get_library_info(libname, create=False)

        log.debug("Unable to find library named: %s", libname)
        return None
